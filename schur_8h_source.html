<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>SRBA: Sparser Relative Bundle Adjustment: srba/impl/schur.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">SRBA: Sparser Relative Bundle Adjustment
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">srba/impl/schur.h</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* +---------------------------------------------------------------------------+</span>
<a name="l00002"></a>00002 <span class="comment">   |                     Mobile Robot Programming Toolkit (MRPT)               |</span>
<a name="l00003"></a>00003 <span class="comment">   |                          http://www.mrpt.org/                             |</span>
<a name="l00004"></a>00004 <span class="comment">   |                                                                           |</span>
<a name="l00005"></a>00005 <span class="comment">   | Copyright (c) 2005-2015, Individual contributors, see AUTHORS file        |</span>
<a name="l00006"></a>00006 <span class="comment">   | See: http://www.mrpt.org/Authors - All rights reserved.                   |</span>
<a name="l00007"></a>00007 <span class="comment">   | Released under BSD License. See details in http://www.mrpt.org/License    |</span>
<a name="l00008"></a>00008 <span class="comment">   +---------------------------------------------------------------------------+ */</span>
<a name="l00009"></a>00009 
<a name="l00010"></a>00010 <span class="preprocessor">#pragma once</span>
<a name="l00011"></a>00011 <span class="preprocessor"></span>
<a name="l00012"></a>00012 <span class="keyword">namespace </span>srba {
<a name="l00013"></a>00013 
<a name="l00016"></a>00016     <span class="keyword">template</span> &lt;<span class="keyword">class</span> HESS_Ap, <span class="keyword">class</span> HESS_f, <span class="keyword">class</span> HESS_Apf&gt;
<a name="l00017"></a><a class="code" href="classsrba_1_1SchurComplement.html">00017</a>     <span class="keyword">class </span><a class="code" href="classsrba_1_1SchurComplement.html">SchurComplement</a>
<a name="l00018"></a>00018     {
<a name="l00019"></a>00019     <span class="keyword">public</span>:
<a name="l00020"></a>00020 
<a name="l00025"></a><a class="code" href="classsrba_1_1SchurComplement.html#a41c6aa807365039ef6d76b797d486b74">00025</a>         <a class="code" href="classsrba_1_1SchurComplement.html#a41c6aa807365039ef6d76b797d486b74">SchurComplement</a>(HESS_Ap  &amp;_HAp, HESS_f &amp; _Hf, HESS_Apf &amp; _HApf, <span class="keywordtype">double</span> * _minus_grad_Ap, <span class="keywordtype">double</span> * _minus_grad_f)
<a name="l00026"></a>00026         : HAp(_HAp), Hf(_Hf), HApf(_HApf),
<a name="l00027"></a>00027           minus_grad_Ap(_minus_grad_Ap),
<a name="l00028"></a>00028           minus_grad_f(_minus_grad_f),
<a name="l00029"></a>00029           <span class="comment">// Problem dims:</span>
<a name="l00030"></a>00030           nUnknowns_Ap( HAp.<a class="codeRef" doxygen="dox_mrpt.tag:http://reference.mrpt.org/devel//" href="http://reference.mrpt.org/devel/eigen__plugins_8h.html#a4d49034b9785c1bd62e4d4540a39066b">getColCount</a>() ),
<a name="l00031"></a>00031           nUnknowns_f( Hf.<a class="codeRef" doxygen="dox_mrpt.tag:http://reference.mrpt.org/devel//" href="http://reference.mrpt.org/devel/eigen__plugins_8h.html#a4d49034b9785c1bd62e4d4540a39066b">getColCount</a>() ),
<a name="l00032"></a>00032           nHf_invertible_blocks(0)
<a name="l00033"></a>00033         {
<a name="l00034"></a>00034             <span class="keywordflow">if</span> (!nUnknowns_f || !nUnknowns_Ap) <span class="keywordflow">return</span>;
<a name="l00035"></a>00035 
<a name="l00036"></a>00036             <span class="comment">// 0) Make copy of the original numerical values of HAp:</span>
<a name="l00037"></a>00037             <span class="comment">// -----------------------------------------------------------------</span>
<a name="l00038"></a>00038             HAp_original.copyNumericalValuesFrom( HAp );
<a name="l00039"></a>00039 
<a name="l00040"></a>00040             <span class="comment">// 1) List of all diagonal blocks in Hf which have to be inverted</span>
<a name="l00041"></a>00041             <span class="comment">// -----------------------------------------------------------------</span>
<a name="l00042"></a>00042             m_Hf_blocks_info.resize(nUnknowns_f);
<a name="l00043"></a>00043             <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0;i&lt;nUnknowns_f;i++)
<a name="l00044"></a>00044             {
<a name="l00045"></a>00045                 <span class="keyword">const</span> <span class="keyword">typename</span> HESS_f::col_t &amp; col_i = Hf.getCol(i);
<a name="l00046"></a>00046                 <a class="codeRef" doxygen="dox_mrpt.tag:http://reference.mrpt.org/devel//" href="http://reference.mrpt.org/devel/mrpt__macros_8h.html#a47eb5a445c2bf3d9190396510ea9683e">ASSERT_</a>(!col_i.empty() &amp;&amp; col_i.rbegin()-&gt;first==i)
<a name="l00047"></a>00047 
<a name="l00048"></a>00048                 m_Hf_blocks_info[i].sym_Hf_diag_blocks = &amp;col_i.rbegin()-&gt;second.num;
<a name="l00049"></a>00049             }
<a name="l00050"></a>00050 
<a name="l00051"></a>00051             <span class="comment">// 2) Build instructions to reduce H_Ap and grad_Ap</span>
<a name="l00052"></a>00052             <span class="comment">// ----------------------------------------------------</span>
<a name="l00053"></a>00053             m_sym_HAp_reduce.clear();
<a name="l00054"></a>00054             m_sym_GradAp_reduce.resize(nUnknowns_Ap);
<a name="l00055"></a>00055 
<a name="l00056"></a>00056             <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0;i&lt;nUnknowns_Ap;i++)
<a name="l00057"></a>00057             {   <span class="comment">// Only upper-half triangle:</span>
<a name="l00058"></a>00058                 <span class="keyword">typename</span> HESS_Ap::col_t &amp; HAp_col_i = HAp.getCol(i);
<a name="l00059"></a>00059 
<a name="l00060"></a>00060                 <span class="comment">// Go thru all the &quot;j&quot; (row) indices in j \in [0,i]</span>
<a name="l00061"></a>00061                 <span class="comment">// even if there&#39;s not an entry in the column map &quot;HAp_col_i&quot; (yet).</span>
<a name="l00062"></a>00062                 <span class="comment">// If the block (i,j) has any feature in common, then we&#39;ll add</span>
<a name="l00063"></a>00063                 <span class="comment">// a block HAp_{i,j} right here and add the corresponding instructions for building the numeric Schur.</span>
<a name="l00064"></a>00064                 <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j=0;j&lt;=i;j++)
<a name="l00065"></a>00065                 {
<a name="l00066"></a>00066                     <span class="comment">// We are at the HAp block (i,j):</span>
<a name="l00067"></a>00067                     <span class="comment">// Make a list of all the:</span>
<a name="l00068"></a>00068                     <span class="comment">//  \Sum H_{pi,lk} * H_{lk}^{-1} *  H_{pj,lk}^t</span>
<a name="l00069"></a>00069                     <span class="comment">//</span>
<a name="l00070"></a>00070                     <span class="comment">// This amounts to looking for the &quot;intersecting set&quot; of the two rows &quot;i&quot; &amp; &quot;j&quot; in HApf:</span>
<a name="l00071"></a>00071                     THApSymbolicEntry  sym_ij;
<a name="l00072"></a>00072 
<a name="l00073"></a>00073                     <span class="comment">// (i==j) -&gt; take advantage of repeated terms and build instructions for the gradient:</span>
<a name="l00074"></a>00074                     TGradApSymbolicEntry *grad_entries = (i==j) ? &amp;m_sym_GradAp_reduce[i] : NULL;
<a name="l00075"></a>00075 
<a name="l00076"></a>00076 
<a name="l00077"></a>00077                     <span class="comment">// get Rows i &amp; j from HAp_f:</span>
<a name="l00078"></a>00078                     <span class="keyword">typename</span> HESS_Apf::col_t  &amp; row_i = HApf.getCol(i);
<a name="l00079"></a>00079                     <span class="keyword">typename</span> HESS_Apf::col_t  &amp; row_j = HApf.getCol(j);
<a name="l00080"></a>00080 
<a name="l00081"></a>00081                     <span class="comment">// code below based on &quot;std::set_intersection&quot;</span>
<a name="l00082"></a>00082                     <span class="keyword">typename</span> HESS_Apf::col_t::const_iterator it_i = row_i.begin();
<a name="l00083"></a>00083                     <span class="keyword">typename</span> HESS_Apf::col_t::const_iterator it_j = row_j.begin();
<a name="l00084"></a>00084                     <span class="keyword">const</span> <span class="keyword">typename</span> HESS_Apf::col_t::const_iterator it_i_end = row_i.end();
<a name="l00085"></a>00085                     <span class="keyword">const</span> <span class="keyword">typename</span> HESS_Apf::col_t::const_iterator it_j_end = row_j.end();
<a name="l00086"></a>00086 
<a name="l00087"></a>00087                     <span class="keywordflow">while</span> (it_i!=it_i_end &amp;&amp; it_j!=it_j_end)
<a name="l00088"></a>00088                     {
<a name="l00089"></a>00089                         <span class="keywordflow">if</span> ( it_i-&gt;first &lt; it_j-&gt;first ) ++it_i;
<a name="l00090"></a>00090                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( it_j-&gt;first &lt; it_i-&gt;first ) ++it_j;
<a name="l00091"></a>00091                         <span class="keywordflow">else</span>
<a name="l00092"></a>00092                         {
<a name="l00093"></a>00093                             <span class="comment">// match between: it_i-&gt;first == it_j-&gt;first</span>
<a name="l00094"></a>00094 
<a name="l00095"></a>00095                             <span class="comment">// Add a new triplet:</span>
<a name="l00096"></a>00096                             <span class="comment">//  * const typename HESS_Apf::matrix_t * Hpi_lk;</span>
<a name="l00097"></a>00097                             <span class="comment">//  * const typename HESS_f::matrix_t   * inv_Hf_lk;</span>
<a name="l00098"></a>00098                             <span class="comment">//  * const typename HESS_Apf::matrix_t * Hpj_lk;</span>
<a name="l00099"></a>00099 
<a name="l00100"></a>00100                             <span class="keyword">const</span> <span class="keywordtype">size_t</span> idx_feat = it_j-&gt;first;
<a name="l00101"></a>00101                             <a class="codeRef" doxygen="dox_mrpt.tag:http://reference.mrpt.org/devel//" href="http://reference.mrpt.org/devel/mrpt__macros_8h.html#a47eb5a445c2bf3d9190396510ea9683e">ASSERT_</a>(idx_feat&lt;nUnknowns_f)
<a name="l00102"></a>00102 
<a name="l00103"></a>00103                             <span class="comment">// Gradient (only if we&#39;re at i==j)</span>
<a name="l00104"></a>00104                             <span class="keyword">typename</span> HESS_Apf::matrix_t *out_temporary_result = NULL;
<a name="l00105"></a>00105                             <span class="keywordflow">if</span> (grad_entries)
<a name="l00106"></a>00106                             {
<a name="l00107"></a>00107                                 grad_entries-&gt;lst_terms_to_subtract.resize( grad_entries-&gt;lst_terms_to_subtract.size()+1 );
<a name="l00108"></a>00108                                 <span class="keyword">typename</span> TGradApSymbolicEntry::TEntry  &amp;ent = *grad_entries-&gt;lst_terms_to_subtract.rbegin();
<a name="l00109"></a>00109                                 ent.feat_idx = idx_feat;
<a name="l00110"></a>00110                                 out_temporary_result = &amp;ent.Hpi_lk_times_inv_Hf_lk;
<a name="l00111"></a>00111                             }
<a name="l00112"></a>00112 
<a name="l00113"></a>00113                             <span class="comment">// Hessian:</span>
<a name="l00114"></a>00114 <span class="preprocessor">#if 0</span>
<a name="l00115"></a>00115 <span class="preprocessor"></span>                            std::cout &lt;&lt; <span class="stringliteral">&quot;SymSchur.HAp(&quot;</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>&lt;&lt;j&lt;&lt; <span class="stringliteral">&quot;): HApf_&quot;</span> &lt;&lt; it_i-&gt;first &lt;&lt; <span class="stringliteral">&quot; * HApf_&quot;</span> &lt;&lt; it_j-&gt;first  &lt;&lt; std::endl;
<a name="l00116"></a>00116 <span class="preprocessor">#endif</span>
<a name="l00117"></a>00117 <span class="preprocessor"></span>                            sym_ij.lst_terms_to_add.push_back( <span class="keyword">typename</span> THApSymbolicEntry::TEntry(
<a name="l00118"></a>00118                                 &amp;it_j-&gt;second.num, <span class="comment">//&amp;it_i-&gt;second.num,</span>
<a name="l00119"></a>00119                                 &amp;m_Hf_blocks_info[idx_feat],
<a name="l00120"></a>00120                                 &amp;it_i-&gt;second.num, <span class="comment">//&amp;it_j-&gt;second.num,</span>
<a name="l00121"></a>00121                                 out_temporary_result ) );
<a name="l00122"></a>00122 
<a name="l00123"></a>00123                             <span class="comment">// Move:</span>
<a name="l00124"></a>00124                             ++it_i; ++it_j;
<a name="l00125"></a>00125                         }
<a name="l00126"></a>00126                     } <span class="comment">// end while (find intersect)</span>
<a name="l00127"></a>00127 
<a name="l00128"></a>00128                     <span class="comment">// Only append if not empty:</span>
<a name="l00129"></a>00129                     <span class="keywordflow">if</span> (!sym_ij.lst_terms_to_add.empty())
<a name="l00130"></a>00130                     {
<a name="l00131"></a>00131                         <span class="comment">// There are common observations between Api &amp; Apj:</span>
<a name="l00132"></a>00132                         <span class="comment">// 1) If there was already an HAp_ij block, take a reference to it.</span>
<a name="l00133"></a>00133                         <span class="comment">// 2) Otherwise, insert it now.</span>
<a name="l00134"></a>00134                         <span class="keyword">typename</span> HESS_Ap::col_t::iterator itExistingRowEntry;
<a name="l00135"></a>00135                         <span class="keywordflow">if</span> ( ((i==j) || (i!=j &amp;&amp; HAp_col_i.size()!=1)) <span class="comment">// If size==1 don&#39;t even waste time: it&#39;s a diagonal block.</span>
<a name="l00136"></a>00136                             &amp;&amp;
<a name="l00137"></a>00137                              (itExistingRowEntry=HAp_col_i.find(j))!= HAp_col_i.end())
<a name="l00138"></a>00138                         {
<a name="l00139"></a>00139                             <span class="comment">// Add reference to target matrix for numeric Schur:</span>
<a name="l00140"></a>00140                             sym_ij.HAp_ij = &amp; itExistingRowEntry -&gt;second.num;
<a name="l00141"></a>00141                         }
<a name="l00142"></a>00142                         <span class="keywordflow">else</span>
<a name="l00143"></a>00143                         {
<a name="l00144"></a>00144                             <a class="codeRef" doxygen="dox_mrpt.tag:http://reference.mrpt.org/devel//" href="http://reference.mrpt.org/devel/mrpt__macros_8h.html#a47eb5a445c2bf3d9190396510ea9683e">ASSERT_</a>(i!=j)  <span class="comment">// We should only reach here for off-diagonal blocks!</span>
<a name="l00145"></a>00145                             <span class="comment">// Create &amp; add reference to target matrix for numeric Schur:</span>
<a name="l00146"></a>00146                             sym_ij.HAp_ij = &amp; HAp_col_i[j].num;
<a name="l00147"></a>00147                             <span class="comment">// Clear initial contents of the Hessian to all zeros:</span>
<a name="l00148"></a>00148                             sym_ij.HAp_ij-&gt;setZero();
<a name="l00149"></a>00149                         }
<a name="l00150"></a>00150 
<a name="l00151"></a>00151                         <span class="comment">// Fast move into the deque:</span>
<a name="l00152"></a>00152                         m_sym_HAp_reduce.resize( m_sym_HAp_reduce.size()+1 );
<a name="l00153"></a>00153                         sym_ij.swap( *m_sym_HAp_reduce.rbegin() );
<a name="l00154"></a>00154                     }
<a name="l00155"></a>00155 
<a name="l00156"></a>00156                 } <span class="comment">// end for j (row in HAp)</span>
<a name="l00157"></a>00157             } <span class="comment">// end for i (col in HAp)</span>
<a name="l00158"></a>00158 
<a name="l00159"></a>00159         } <span class="comment">// end of ctor.</span>
<a name="l00160"></a>00160 
<a name="l00165"></a><a class="code" href="classsrba_1_1SchurComplement.html#a7a35eff45ffd329a952bc88d9fc611b4">00165</a>         <span class="keywordtype">void</span> <a class="code" href="classsrba_1_1SchurComplement.html#a7a35eff45ffd329a952bc88d9fc611b4">realize_HAp_changed</a>()
<a name="l00166"></a>00166         {
<a name="l00167"></a>00167             HAp_original.copyNumericalValuesFrom( HAp );
<a name="l00168"></a>00168         }
<a name="l00169"></a>00169 
<a name="l00171"></a><a class="code" href="classsrba_1_1SchurComplement.html#aa6a2e3d689a7fefb228c1cdfda8199ba">00171</a>         <span class="keywordtype">size_t</span> <a class="code" href="classsrba_1_1SchurComplement.html#aa6a2e3d689a7fefb228c1cdfda8199ba">getNumFeatures</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> nUnknowns_f; }
<a name="l00172"></a>00172         <span class="keywordtype">size_t</span> getNumFeaturesFullRank()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> nHf_invertible_blocks; }
<a name="l00173"></a>00173 
<a name="l00174"></a>00174 
<a name="l00180"></a><a class="code" href="classsrba_1_1SchurComplement.html#a47cc61b86f26a9076254038a5c78d7b2">00180</a>         <span class="keywordtype">void</span> <a class="code" href="classsrba_1_1SchurComplement.html#a47cc61b86f26a9076254038a5c78d7b2">numeric_build_reduced_system</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> lambda)
<a name="l00181"></a>00181         {
<a name="l00182"></a>00182             <span class="keywordflow">if</span> (!nUnknowns_f || !nUnknowns_Ap) <span class="keywordflow">return</span>;
<a name="l00183"></a>00183 
<a name="l00184"></a>00184             <span class="comment">// 0) Restore the original state of the Hessian (since all changes are defined as sums / substractions on it)</span>
<a name="l00185"></a>00185             <span class="comment">//     and this operation can be invoked several times with the same original HAp but diferent lambda values</span>
<a name="l00186"></a>00186             <span class="comment">//     (which forces a total recomputation due to the inv(Hf+\lambda*I) terms).</span>
<a name="l00187"></a>00187             <span class="comment">// --------------------------------------------------------------------------------</span>
<a name="l00188"></a>00188             HAp.copyNumericalValuesFrom( HAp_original );
<a name="l00189"></a>00189 
<a name="l00190"></a>00190             <span class="comment">// 1) Invert diagonal blocks in Hf:</span>
<a name="l00191"></a>00191             <span class="comment">// ---------------------------------</span>
<a name="l00192"></a>00192             nHf_invertible_blocks=0;
<a name="l00193"></a>00193             <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0;i&lt;nUnknowns_f;i++)
<a name="l00194"></a>00194             {
<a name="l00195"></a>00195                 <span class="comment">// LU decomposition is rank-revealing (not like LLt)</span>
<a name="l00196"></a>00196                 <span class="keyword">typename</span> HESS_f::matrix_t Hfi = *m_Hf_blocks_info[i].sym_Hf_diag_blocks;
<a name="l00197"></a>00197                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0;k&lt;Hfi.cols();k++)
<a name="l00198"></a>00198                     Hfi.coeffRef(k,k)+=lambda;
<a name="l00199"></a>00199 
<a name="l00200"></a>00200                 <span class="keyword">const</span> Eigen::FullPivLU&lt;typename HESS_f::matrix_t&gt; lu( Hfi );
<a name="l00201"></a>00201 
<a name="l00202"></a>00202                 <span class="comment">// Badly conditioned matrix?</span>
<a name="l00203"></a>00203                 <span class="keywordflow">if</span> (<span class="keyword">true</span>== (m_Hf_blocks_info[i].num_Hf_diag_blocks_invertible = lu.isInvertible() ))
<a name="l00204"></a>00204                 {
<a name="l00205"></a>00205                     nHf_invertible_blocks++;
<a name="l00206"></a>00206                     m_Hf_blocks_info[i].num_Hf_diag_blocks_inverses = lu.inverse();
<a name="l00207"></a>00207                 }
<a name="l00208"></a>00208             }
<a name="l00209"></a>00209 
<a name="l00210"></a>00210             <span class="comment">// 2) H_Ap of the reduced system:</span>
<a name="l00211"></a>00211             <span class="comment">// ---------------------------------</span>
<a name="l00212"></a>00212             <span class="keyword">typename</span> HESS_Apf::matrix_t aux_Hpi_lk_times_inv_Hf_lk;
<a name="l00213"></a>00213             <span class="keywordflow">for</span> (<span class="keyword">typename</span> std::deque&lt;THApSymbolicEntry&gt;::const_iterator it=m_sym_HAp_reduce.begin();it!=m_sym_HAp_reduce.end();++it)
<a name="l00214"></a>00214             {
<a name="l00215"></a>00215                 <span class="keyword">const</span> THApSymbolicEntry &amp;sym_entry = *it;
<a name="l00216"></a>00216 
<a name="l00217"></a>00217                 <span class="keyword">typename</span> HESS_Ap::matrix_t &amp; HAp_ij = *sym_entry.HAp_ij;
<a name="l00218"></a>00218 
<a name="l00219"></a>00219                 <span class="keyword">const</span> <span class="keywordtype">size_t</span> N = sym_entry.lst_terms_to_add.size();
<a name="l00220"></a>00220 
<a name="l00221"></a>00221                 <span class="comment">//std::cout &lt;&lt; &quot;before:\n&quot; &lt;&lt; HAp_ij &lt;&lt; std::endl;</span>
<a name="l00222"></a>00222                 <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0;i&lt;N;i++)
<a name="l00223"></a>00223                 {
<a name="l00224"></a>00224                     <span class="keyword">const</span> <span class="keyword">typename</span> THApSymbolicEntry::TEntry &amp;entry = sym_entry.lst_terms_to_add[i];
<a name="l00225"></a>00225 
<a name="l00226"></a>00226                     <span class="keywordflow">if</span> (entry.inv_Hf_lk-&gt;num_Hf_diag_blocks_invertible)
<a name="l00227"></a>00227                     {
<a name="l00228"></a>00228                         <span class="comment">//cout &lt;&lt; &quot;Hfinv:\n&quot; &lt;&lt; entry.inv_Hf_lk-&gt;num_Hf_diag_blocks_inverses  &lt;&lt; endl;</span>
<a name="l00229"></a>00229                         <span class="comment">// \bar{Hp} -=  Hpi_lk * inv(Hf_lk) * Hpj_lk^t</span>
<a name="l00230"></a>00230 
<a name="l00231"></a>00231                         <span class="comment">// Store this term for reuse with the gradient update, or use temporary local storage:</span>
<a name="l00232"></a>00232                         <span class="keyword">typename</span> HESS_Apf::matrix_t * Hpi_lk_times_inv_Hf_lk =
<a name="l00233"></a>00233                             entry.out_Hpi_lk_times_inv_Hf_lk!=NULL
<a name="l00234"></a>00234                             ?
<a name="l00235"></a>00235                             entry.out_Hpi_lk_times_inv_Hf_lk : &amp;aux_Hpi_lk_times_inv_Hf_lk;
<a name="l00236"></a>00236 
<a name="l00237"></a>00237                         Hpi_lk_times_inv_Hf_lk-&gt;noalias() = (*entry.Hpi_lk) * entry.inv_Hf_lk-&gt;num_Hf_diag_blocks_inverses;
<a name="l00238"></a>00238 
<a name="l00239"></a>00239                         <span class="comment">//std::cout &lt;&lt; &quot;product #&quot; &lt;&lt; i &lt;&lt; &quot;:\nHpi_lk:\n&quot; &lt;&lt; (*entry.Hpi_lk) &lt;&lt; &quot;\nHfi^-1:\n&quot; &lt;&lt; entry.inv_Hf_lk-&gt;num_Hf_diag_blocks_inverses &lt;&lt; &quot;\nHpj_lk^t:\n&quot; &lt;&lt; entry.Hpj_lk-&gt;transpose() &lt;&lt; &quot;\n\n&quot;;</span>
<a name="l00240"></a>00240                         HAp_ij.noalias() -= (*Hpi_lk_times_inv_Hf_lk) * (*entry.Hpj_lk).transpose();
<a name="l00241"></a>00241                     }
<a name="l00242"></a>00242                 }
<a name="l00243"></a>00243                 <span class="comment">//std::cout &lt;&lt; &quot;after:\n&quot; &lt;&lt; HAp_ij&lt;&lt; std::endl;</span>
<a name="l00244"></a>00244             }
<a name="l00245"></a>00245 
<a name="l00246"></a>00246             <span class="comment">// 3) g_Ap of the reduced system:</span>
<a name="l00247"></a>00247             <span class="comment">// ---------------------------------</span>
<a name="l00248"></a>00248             <span class="keywordtype">double</span> * modified_grad_Ap = minus_grad_Ap;
<a name="l00249"></a>00249             <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0;i&lt;nUnknowns_Ap;i++)
<a name="l00250"></a>00250             {
<a name="l00251"></a>00251                 vector_Ap_t grad_Ap = vector_Ap_t(modified_grad_Ap); <span class="comment">// A map which wraps the pointer</span>
<a name="l00252"></a>00252                 <span class="keywordflow">for</span> (<span class="keyword">typename</span> TGradApSymbolicEntry::lst_terms_t::const_iterator it=m_sym_GradAp_reduce[i].lst_terms_to_subtract.begin();it!=m_sym_GradAp_reduce[i].lst_terms_to_subtract.end();++it)
<a name="l00253"></a>00253                 {
<a name="l00254"></a>00254                     <span class="keywordflow">if</span> (m_Hf_blocks_info[it-&gt;feat_idx].num_Hf_diag_blocks_invertible)
<a name="l00255"></a>00255                     {
<a name="l00256"></a>00256                         <span class="keywordtype">double</span> *grad_df = this-&gt;minus_grad_f + it-&gt;feat_idx * HESS_f::matrix_t::RowsAtCompileTime;
<a name="l00257"></a>00257                         <span class="comment">// g -= \Sum Hpi_lk * inv(Hf_lk) * grad_lk</span>
<a name="l00258"></a>00258                         <span class="comment">//</span>
<a name="l00259"></a>00259                         grad_Ap.noalias() -= it-&gt;Hpi_lk_times_inv_Hf_lk * vector_f_t(grad_df);
<a name="l00260"></a>00260                     }
<a name="l00261"></a>00261                 }
<a name="l00262"></a>00262 
<a name="l00263"></a>00263                 <span class="comment">// Advance to next part of gradient:</span>
<a name="l00264"></a>00264                 modified_grad_Ap+= HESS_Ap::matrix_t::RowsAtCompileTime;
<a name="l00265"></a>00265             }
<a name="l00266"></a>00266 
<a name="l00267"></a>00267 
<a name="l00268"></a>00268         } <span class="comment">// end of numeric_build_reduced_system</span>
<a name="l00269"></a>00269 
<a name="l00270"></a>00270 
<a name="l00271"></a>00271         <span class="keywordtype">void</span> numeric_solve_for_features(
<a name="l00272"></a>00272             <span class="keywordtype">double</span> *in_deltas_Ap,
<a name="l00273"></a>00273             <span class="keywordtype">double</span> *out_deltas_feats
<a name="l00274"></a>00274             )
<a name="l00275"></a>00275         {
<a name="l00276"></a>00276             <span class="comment">// 1/2: Go thru all the Hessian blocks of HApl and subtracts the corresponding term to</span>
<a name="l00277"></a>00277             <span class="comment">//       the grad_feats:</span>
<a name="l00278"></a>00278             <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> idx_Ap=0;idx_Ap&lt;nUnknowns_Ap;idx_Ap++)
<a name="l00279"></a>00279             {
<a name="l00280"></a>00280                 <span class="comment">// get Row i from HAp_f:</span>
<a name="l00281"></a>00281                 <span class="keyword">typename</span> HESS_Apf::col_t  &amp; row_i = HApf.getCol(idx_Ap);
<a name="l00282"></a>00282 
<a name="l00283"></a>00283                 <span class="keyword">const</span> vector_Ap_t delta_idx_Ap = vector_Ap_t(in_deltas_Ap + idx_Ap * HESS_Ap::matrix_t::RowsAtCompileTime );
<a name="l00284"></a>00284 
<a name="l00285"></a>00285                 <span class="keywordflow">for</span> (<span class="keyword">typename</span> HESS_Apf::col_t::const_iterator itCol=row_i.begin();itCol!=row_i.end();++itCol)
<a name="l00286"></a>00286                 {
<a name="l00287"></a>00287                     <span class="keyword">const</span> <span class="keywordtype">size_t</span> idx_feat = itCol-&gt;first;
<a name="l00288"></a>00288                     <span class="keywordflow">if</span> (!was_ith_feature_invertible(idx_feat))
<a name="l00289"></a>00289                         <span class="keywordflow">continue</span>;
<a name="l00290"></a>00290 
<a name="l00291"></a>00291                     <span class="keywordtype">double</span> *grad_df = this-&gt;minus_grad_f + idx_feat * HESS_f::matrix_t::RowsAtCompileTime;
<a name="l00292"></a>00292 
<a name="l00293"></a>00293                     <span class="comment">// g_reduced = -g_l - \Sum H^t_pi_lk * delta_Ap_i</span>
<a name="l00294"></a>00294                     vector_f_t(grad_df).noalias() -= itCol-&gt;second.num.transpose() * delta_idx_Ap;
<a name="l00295"></a>00295                 }
<a name="l00296"></a>00296             }
<a name="l00297"></a>00297 
<a name="l00298"></a>00298             <span class="comment">// 2/2: Solve each individual feature increment:</span>
<a name="l00299"></a>00299             <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> idx_feat=0;idx_feat&lt;nUnknowns_f;idx_feat++)
<a name="l00300"></a>00300             {
<a name="l00301"></a>00301                 <span class="keywordflow">if</span> (!was_ith_feature_invertible(idx_feat))
<a name="l00302"></a>00302                     <span class="keywordflow">continue</span>;
<a name="l00303"></a>00303 
<a name="l00304"></a>00304                 vector_f_t delta_feat = vector_f_t(  out_deltas_feats + idx_feat * HESS_f::matrix_t::RowsAtCompileTime );
<a name="l00305"></a>00305                 vector_f_t grad_df    = vector_f_t(this-&gt;minus_grad_f + idx_feat * HESS_f::matrix_t::RowsAtCompileTime );
<a name="l00306"></a>00306                 <span class="comment">//std::cout  &lt;&lt; grad_df.transpose() &lt;&lt; std::endl &lt;&lt; m_Hf_blocks_info[idx_feat].num_Hf_diag_blocks_inverses &lt;&lt; std::endl &lt;&lt; std::endl;</span>
<a name="l00307"></a>00307 
<a name="l00308"></a>00308                 delta_feat = (m_Hf_blocks_info[idx_feat].num_Hf_diag_blocks_inverses * grad_df);
<a name="l00309"></a>00309             }
<a name="l00310"></a>00310 
<a name="l00311"></a>00311         } <span class="comment">// end of numeric_solve_for_features</span>
<a name="l00312"></a>00312 
<a name="l00313"></a>00313 
<a name="l00314"></a>00314         <span class="keywordtype">bool</span> was_ith_feature_invertible(<span class="keyword">const</span> <span class="keywordtype">size_t</span> i)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_Hf_blocks_info[i].num_Hf_diag_blocks_invertible; }
<a name="l00315"></a>00315 
<a name="l00316"></a>00316     <span class="keyword">private</span>:
<a name="l00317"></a>00317         <span class="comment">// ----------- Input data ------------------</span>
<a name="l00318"></a>00318         HESS_Ap    HAp_original;  <span class="comment">// (Copy of the numerical values of HAp)</span>
<a name="l00319"></a>00319         HESS_Ap  &amp; HAp;  <span class="comment">// Column compressed</span>
<a name="l00320"></a>00320         HESS_f   &amp; Hf;   <span class="comment">// Column compressed</span>
<a name="l00321"></a>00321         HESS_Apf &amp; HApf; <span class="comment">// *ROW* compressed</span>
<a name="l00322"></a>00322         <span class="keywordtype">double</span>   * minus_grad_Ap;
<a name="l00323"></a>00323         <span class="keywordtype">double</span>   * minus_grad_f;   <span class="comment">// Should be changed to &quot;const&quot; if used a Eigen::&quot;ConstMap&quot;...</span>
<a name="l00324"></a>00324 
<a name="l00325"></a>00325         <span class="keyword">const</span> <span class="keywordtype">size_t</span> nUnknowns_Ap;
<a name="l00326"></a>00326         <span class="keyword">const</span> <span class="keywordtype">size_t</span> nUnknowns_f;
<a name="l00327"></a>00327         <span class="keywordtype">size_t</span> nHf_invertible_blocks; 
<a name="l00328"></a>00328         <span class="comment">// -----------------------------------------</span>
<a name="l00329"></a>00329         <span class="keyword">typedef</span> <span class="keyword">typename</span> Eigen::Map&lt;Eigen::Matrix&lt;double,HESS_Ap::matrix_t::RowsAtCompileTime,1&gt; &gt; vector_Ap_t;
<a name="l00330"></a>00330         <span class="keyword">typedef</span> <span class="keyword">typename</span> Eigen::Map&lt;Eigen::Matrix&lt;double,HESS_f::matrix_t::RowsAtCompileTime,1&gt; &gt; vector_f_t;
<a name="l00331"></a>00331 
<a name="l00332"></a>00332 
<a name="l00333"></a>00333         <span class="keyword">struct </span>TInfoPerHfBlock
<a name="l00334"></a>00334         {
<a name="l00335"></a>00335             <span class="keyword">const</span> <span class="keyword">typename</span> HESS_f::matrix_t * sym_Hf_diag_blocks;
<a name="l00336"></a>00336             <span class="keyword">typename</span> HESS_f::matrix_t         num_Hf_diag_blocks_inverses;
<a name="l00337"></a>00337             <span class="keywordtype">bool</span>                              num_Hf_diag_blocks_invertible; 
<a name="l00338"></a>00338 
<a name="l00339"></a>00339             TInfoPerHfBlock() : sym_Hf_diag_blocks(NULL), num_Hf_diag_blocks_invertible(false) { }
<a name="l00340"></a>00340 
<a name="l00341"></a>00341             <a class="codeRef" doxygen="dox_mrpt.tag:http://reference.mrpt.org/devel//" href="http://reference.mrpt.org/devel/memory_8h.html#ae8980bd7f8c37e72ce7763c5d94f0076">MRPT_MAKE_ALIGNED_OPERATOR_NEW</a>
<a name="l00342"></a>00342         };
<a name="l00343"></a>00343 
<a name="l00344"></a>00344         <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="dox_mrpt.tag:http://reference.mrpt.org/devel//" href="http://reference.mrpt.org/devel/structmrpt_1_1aligned__containers.html#a85594e0b9e8a9bf5c623a19b4a971e91">mrpt::aligned_containers&lt;TInfoPerHfBlock&gt;::vector_t</a> TInfoPerHfBlock_vector_t;
<a name="l00345"></a>00345 
<a name="l00346"></a>00346         TInfoPerHfBlock_vector_t  m_Hf_blocks_info;
<a name="l00347"></a>00347 
<a name="l00349"></a>00349         <span class="keyword">struct </span>THApSymbolicEntry
<a name="l00350"></a>00350         {
<a name="l00351"></a><a class="code" href="structsrba_1_1SchurComplement_1_1THApSymbolicEntry_1_1TEntry.html">00351</a>             <span class="keyword">struct </span><a class="code" href="structsrba_1_1SchurComplement_1_1THApSymbolicEntry_1_1TEntry.html">TEntry</a>
<a name="l00352"></a>00352             {
<a name="l00353"></a>00353                 <a class="code" href="structsrba_1_1SchurComplement_1_1THApSymbolicEntry_1_1TEntry.html">TEntry</a>(
<a name="l00354"></a>00354                     <span class="keyword">const</span> <span class="keyword">typename</span> HESS_Apf::matrix_t * _Hpi_lk,
<a name="l00355"></a>00355                     <span class="keyword">const</span> TInfoPerHfBlock             * _inv_Hf_lk,
<a name="l00356"></a>00356                     <span class="keyword">const</span> <span class="keyword">typename</span> HESS_Apf::matrix_t * _Hpj_lk,
<a name="l00357"></a>00357                     <span class="keyword">typename</span> HESS_Apf::matrix_t       * _out_Hpi_lk_times_inv_Hf_lk
<a name="l00358"></a>00358                     )
<a name="l00359"></a>00359                     :
<a name="l00360"></a>00360                         Hpi_lk(_Hpi_lk),
<a name="l00361"></a>00361                         inv_Hf_lk(_inv_Hf_lk),
<a name="l00362"></a>00362                         Hpj_lk(_Hpj_lk),
<a name="l00363"></a>00363                         <a class="code" href="structsrba_1_1SchurComplement_1_1THApSymbolicEntry_1_1TEntry.html#a62af3dd64e3e59abae6e9a8f9814c498" title="If NULL=use local storage.">out_Hpi_lk_times_inv_Hf_lk</a>(_out_Hpi_lk_times_inv_Hf_lk)
<a name="l00364"></a>00364                 {
<a name="l00365"></a>00365                 }
<a name="l00366"></a>00366 
<a name="l00367"></a>00367                 <span class="keyword">const</span> <span class="keyword">typename</span> HESS_Apf::matrix_t * Hpi_lk;
<a name="l00368"></a>00368                 <span class="keyword">const</span> TInfoPerHfBlock             * inv_Hf_lk;
<a name="l00369"></a>00369                 <span class="keyword">const</span> <span class="keyword">typename</span> HESS_Apf::matrix_t * Hpj_lk;
<a name="l00370"></a><a class="code" href="structsrba_1_1SchurComplement_1_1THApSymbolicEntry_1_1TEntry.html#a62af3dd64e3e59abae6e9a8f9814c498">00370</a>                 <span class="keyword">typename</span> HESS_Apf::matrix_t       * <a class="code" href="structsrba_1_1SchurComplement_1_1THApSymbolicEntry_1_1TEntry.html#a62af3dd64e3e59abae6e9a8f9814c498" title="If NULL=use local storage.">out_Hpi_lk_times_inv_Hf_lk</a>;  
<a name="l00371"></a>00371             };
<a name="l00372"></a>00372 
<a name="l00373"></a>00373             <span class="keyword">typename</span> HESS_Ap::matrix_t * HAp_ij;
<a name="l00374"></a>00374             std::deque&lt;TEntry&gt;          lst_terms_to_add;
<a name="l00375"></a>00375 
<a name="l00376"></a>00376             <span class="keywordtype">void</span> swap(THApSymbolicEntry &amp;o)
<a name="l00377"></a>00377             {
<a name="l00378"></a>00378                 std::swap(HAp_ij,o.HAp_ij);
<a name="l00379"></a>00379                 lst_terms_to_add.swap(o.lst_terms_to_add);
<a name="l00380"></a>00380             }
<a name="l00381"></a>00381         };
<a name="l00382"></a>00382 
<a name="l00383"></a>00383         std::deque&lt;THApSymbolicEntry&gt;  m_sym_HAp_reduce;  
<a name="l00384"></a>00384 
<a name="l00385"></a>00385 
<a name="l00386"></a>00386         <span class="keyword">struct </span>TGradApSymbolicEntry
<a name="l00387"></a>00387         {
<a name="l00388"></a><a class="code" href="structsrba_1_1SchurComplement_1_1TGradApSymbolicEntry_1_1TEntry.html">00388</a>             <span class="keyword">struct </span><a class="code" href="structsrba_1_1SchurComplement_1_1TGradApSymbolicEntry_1_1TEntry.html">TEntry</a>
<a name="l00389"></a>00389             {
<a name="l00390"></a>00390                 <span class="keywordtype">size_t</span> feat_idx;
<a name="l00391"></a>00391                 <span class="comment">// Used as a temporary container for the product, but also because this term reappears in the gradient update:</span>
<a name="l00392"></a>00392                 <span class="keyword">typename</span> HESS_Apf::matrix_t         Hpi_lk_times_inv_Hf_lk;
<a name="l00393"></a>00393 
<a name="l00394"></a>00394                 <a class="codeRef" doxygen="dox_mrpt.tag:http://reference.mrpt.org/devel//" href="http://reference.mrpt.org/devel/memory_8h.html#ae8980bd7f8c37e72ce7763c5d94f0076">MRPT_MAKE_ALIGNED_OPERATOR_NEW</a>
<a name="l00395"></a>00395             };
<a name="l00396"></a>00396 
<a name="l00397"></a>00397 <span class="comment">// BUG ALERT in Eigen/Deque/MSVC 2008 32bit: http://eigen.tuxfamily.org/bz/show_bug.cgi?id=83</span>
<a name="l00398"></a>00398 <span class="comment">// This workaround will lose performance but at least allow compiling. Remove this if someday a solution</span>
<a name="l00399"></a>00399 <span class="comment">// to the bug above is found:</span>
<a name="l00400"></a>00400 <span class="preprocessor">#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &lt; 1600)  // if we use MSVC older than 2010:</span>
<a name="l00401"></a>00401 <span class="preprocessor"></span>            <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="dox_mrpt.tag:http://reference.mrpt.org/devel//" href="http://reference.mrpt.org/devel/structmrpt_1_1aligned__containers.html#a9e6a6c90e71df92f584b1ec3d01f74bb">mrpt::aligned_containers&lt;TEntry&gt;::list_t</a> lst_terms_t;  <span class="comment">// slower than deque, but works...</span>
<a name="l00402"></a>00402 <span class="preprocessor">#else</span>
<a name="l00403"></a>00403 <span class="preprocessor"></span>            <span class="comment">// (Warning: Don&#39;t replace the STL container with &quot;vector&quot; or any other that invalidate</span>
<a name="l00404"></a>00404             <span class="comment">// pointers, which is assumed in the implementation. That&#39;s why I use &quot;std::deque&quot;)</span>
<a name="l00405"></a>00405             <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="dox_mrpt.tag:http://reference.mrpt.org/devel//" href="http://reference.mrpt.org/devel/structmrpt_1_1aligned__containers.html#af7a0bac8608c911b99053d8213110ba3">mrpt::aligned_containers&lt;TEntry&gt;::deque_t</a> lst_terms_t;
<a name="l00406"></a>00406 <span class="preprocessor">#endif</span>
<a name="l00407"></a>00407 <span class="preprocessor"></span>            <span class="comment">// The list itself:</span>
<a name="l00408"></a>00408             lst_terms_t  lst_terms_to_subtract;
<a name="l00409"></a>00409         };
<a name="l00410"></a>00410         std::vector&lt;TGradApSymbolicEntry&gt; m_sym_GradAp_reduce;  
<a name="l00411"></a>00411 
<a name="l00412"></a>00412     };  <span class="comment">// end of class SchurComplement</span>
<a name="l00413"></a>00413 
<a name="l00414"></a>00414 } <span class="comment">// end of namespaces</span>
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Mon Nov 9 2015 10:15:30 for SRBA: Sparser Relative Bundle Adjustment by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
